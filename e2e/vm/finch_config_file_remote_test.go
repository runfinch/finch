// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//go:build darwin || windows

package vm

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"time"

	"github.com/onsi/ginkgo/v2"
	"github.com/onsi/gomega"
	"github.com/runfinch/common-tests/command"
	"github.com/runfinch/common-tests/ffs"
	"github.com/runfinch/common-tests/fnet"
	"github.com/runfinch/common-tests/option"
)

// testFinchConfigFile makes sure that DOCKER_CONFIG is properly set to ~/.finch so that related information
// is written to ~/.finch/config.json file.
var testFinchConfigFile = func(o *option.Option) {
	ginkgo.Describe("finch config file", func() {
		ginkgo.It("should store login credentials", func() {
			// Ensure clean config at start
			var finchRootDir string
			var err error
			if runtime.GOOS == "windows" {
				finchRootDir = os.Getenv("LOCALAPPDATA")
			} else {
				finchRootDir, err = os.UserHomeDir()
				gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
			}
			configPath := filepath.Join(finchRootDir, ".finch", "config.json")
			_ = os.Remove(configPath)
			ginkgo.DeferCleanup(os.Remove, configPath)

			// Check keychain availability
			if runtime.GOOS == "darwin" {
				keychainPath := filepath.Join(finchRootDir, "Library", "Keychains", "login.keychain-db")
				if _, err := os.Stat(keychainPath); err != nil {
					fmt.Printf("DEBUG: Login keychain not found at %s: %v\n", keychainPath, err)
				} else {
					fmt.Printf("DEBUG: Login keychain exists at %s\n", keychainPath)
				}
			}

			fmt.Printf("DEBUG: Config before login - checking %s\n", configPath)
			// #nosec G304 -- configPath is constructed from user home directory, not user input
			if data, err := os.ReadFile(configPath); err == nil {
				fmt.Printf("DEBUG: Config exists before login: %s\n", string(data))
			} else {
				fmt.Printf("DEBUG: Config does not exist before login: %v\n", err)
			}

			filename := "htpasswd"
			registryImage := "public.ecr.aws/docker/library/registry:2"
			registryContainer := "auth-registry"
			// The htpasswd is generated by
			// `finch run --entrypoint htpasswd public.ecr.aws/docker/library/httpd:2 -Bbn testUser testPassword`.
			// We don't want to generate it on the fly because:
			// 1. Pulling the httpd image can take a long time, sometimes even more 10 seconds.
			// 2. It's unlikely that we will have to update this in the future.
			// 3. It's not the thing we want to validate by the functional tests. We only want the output produced by it.
			//nolint:gosec // This password is only used for testing purpose.
			htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
			htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
			ginkgo.DeferCleanup(os.RemoveAll, htpasswdDir)
			port := fnet.GetFreePort()
			containerID := command.StdoutStr(o, "run",
				"-dp", fmt.Sprintf("%d:5000", port),
				"--name", registryContainer,
				"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
				"-e", "REGISTRY_AUTH=htpasswd",
				"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
				"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
				registryImage)
			ginkgo.DeferCleanup(command.Run, o, "rmi", "-f", registryImage)
			ginkgo.DeferCleanup(command.Run, o, "rm", "-f", registryContainer)
			tries := 0
			for command.StdoutStr(o, "inspect", "-f", "{{.State.Running}}", containerID) != "true" {
				if tries >= 5 {
					ginkgo.Fail("Registry container failed to start after 5 seconds")
				}
				time.Sleep(1 * time.Second)
				tries++
			}
			time.Sleep(10 * time.Second)
			registry := fmt.Sprintf(`localhost:%d`, port)
			fmt.Printf("DEBUG: Attempting login to %s\n", registry)
			loginSession := command.New(o, "login", registry, "-u", "testUser", "-p", "testPassword").WithoutCheckingExitCode().Run()
			fmt.Printf("DEBUG: Login exit code: %d\n", loginSession.ExitCode())
			gomega.Expect(loginSession.ExitCode()).Should(gomega.Equal(0))

			fmt.Printf("DEBUG: Config after login - reading %s\n", configPath)
			configContent, err := os.ReadFile(filepath.Clean(configPath))
			gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
			fmt.Printf("DEBUG: Config content after login: %s\n", string(configContent))

			gomega.Expect(string(configContent)).Should(gomega.ContainSubstring(registry))
			command.Run(o, "logout", registry)

			configContent, err = os.ReadFile(filepath.Clean(configPath))
			gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
			gomega.Expect(string(configContent)).ShouldNot(gomega.ContainSubstring(registry))
		})
	})
}
